/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
Eliminadas producciones para manejar globos
Agregado el esqueleto para la traduccion
Modificado por Silvia Takahashi 
Re: Agregar Reglas para el manejo de globos
Modificado por Saulo Daza y Sonia Vivas
Modificado por Silvia Takahashi
Eliminadas reglas de traducci�n DE  MARCROS
Cambio del lenguaje de comandos
Modificado por Silvia Takahashi: algunas Reglas para traduccion
Modificado por Silvia Takahashi: Cambio en el lenguaje
Abril: 2008 - Simplificado apra solo interpretaci�n
 **/

/*
Project 1
Juan José Osorio Cálad 202021720 j.osorio
Luis Alejandro Rubiano

*/

options 
{
	LOOKAHEAD=2;
	FORCE_LA_CHECK = true; // salen dos warnings de: Choice conflict involving two expansions at...
	IGNORE_CASE = false;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

@SuppressWarnings("serial")
public class Robot 
{
	// ArrayList<String > varDefinidas = new ArrayList(); // Variables definidas

	HashMap<String, Integer > varDefinidas = new HashMap<String, Integer >();

	private RobotWorldDec world;
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
	" "
	| "    "
	|  "\r"
	|"\t"
//	|"\n" //TODO: Check
}

TOKEN: /* Nombres de Comandos */
{
	< MOVE: "MOVE" > //INT where n is a number or a previously defined variable
| 	< RIGHT: "RIGHT" > //INT where n is a number or a previously defined variable
|	< LEFT: "LEFT" > //INT where n is a number or a previously defined variable
|	< ROTATE: "ROTATE" > //INT where n is a number or a previously defined variable
|	< LOOK: "LOOK" > // STRING where O can be N, E, W, or S
|	< DROP: "DROP" > // INT where n is a number or a previously defined variable
|	< FREE: "FREE" > // INT where n is a number or a previously defined variable
|	< PICK: "PICK" > // INT where n is a number or a previously defined variable
|	< POP: "POP" > // INT where n is a number or a previously defined variable
|	< CHECK: "CHECK" > // where O is either C for chips, or B for balloons, and n is a previously defined variable or a number
|	< BLOCKEDP: "BLOCKEDP" > //Boolean
|	< NOP: "NOP" > // The Robot doesn't do anything
}



TOKEN: /* Nombres de Comandos Especiales*/
{
	< BLOCK: "BLOCK" > // (BLOCK commands) where commands is simply a sequence of one or more commands (separated by new lines)
|	< REPEAT: "REPEAT" > /*
REPEAT n [commands], where n is a variable or a number
describing the number of times the commands inside the [] will repeat, and
commands is a sequence of basic commands separated by new lines
*/
| 	< IF: "IF" > /*
IF expr [ commands ], where expr is a boolean ex-
pression, and commands is a sequence of basic commands separated by new
lines
*/
| 	< DEFINE: "DEFINE" > /*
DEFINE n val – defines a new variable n assigning it value val (an integer).
Note that variable names need to be lowercase
*/
| < TO: "TO" > /*
TO f :param OUTPUT expression END. Functions are defined between the TO
and END keywords, giving them a name f and a list of space separated parame-
ters each defined by the colons before its name (as in :param). The inner works
of a function are given as an expression or block of commands in its OUTPUT.
*/
| 	< OUTPUT: "OUTPUT" >
| 	< END: "END" >
}


TOKEN :
{
	<NUMERO: (<DIGIT>)+ >
	|  	<#DIGIT: ["0"-"9"] >
	// Identifier
	| < #LETRAS: ["a"-"z"] >
	| < #MAY: ["A"-"Z"] >
	| < ID: (< LETRAS >|< MAY >|< NUMERO >)+ >
		
}


// RP de movimientos
void move():
{}
{
  < MOVE >  (< NUMERO >
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 })
)
}


void right():
{ }
{
	< RIGHT >  (< NUMERO >
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 })
)
}


void left():
{ }
{
	< LEFT >  (< NUMERO >
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 })
)
}


void rotate():
{ }
{
	< ROTATE >  (< NUMERO >
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 })
)
}


void look():
{
	ArrayList<String> charValidos = new ArrayList<String>(Arrays.asList("N", "S", "E", "W"));
}
{
	< LOOK >  < ID >
	{

	if (!(charValidos.contains(token.image))) // Check if CHAR is in charValidos
	{
		throw new Error("\""+ token.image + "\"" + " should be either \"N\", \"S\", \"E\", \"W\"!");
	}

	}
}

void drop():
{ }
{
	< DROP>  (< NUMERO >
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 })
)
}


void free():
{ }
{
	< FREE >  (< NUMERO >
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 })
)
}


void pick():
{ }
{
	< PICK >  (< NUMERO >
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 })
)
}


void pop():
{ }
{
	< POP >  (< NUMERO >
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 })
)
}


void check():
{
	ArrayList<String> charValidos = new ArrayList<String>(Arrays.asList("C", "B"));
}
{
	< CHECK >  < ID >
	{
		if(!(charValidos.contains(token.image)))
		{
			throw new Error("\""+ token.image + "\"" + " should be \"C\" or \"B\"!");
		}
	}
	
	(< NUMERO >
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 })
)
}


// BLOCKEDP


// NOP


void block():
{}
{
	"(" < BLOCK > 

	// TODO: Comandos/ Toca hacer una RP para que se incluyan los comandos separados por /n
	 comandosMain() (comandosMain())*

	
	(")"|("\n")+ ")") // Final de paréntesis
}


void repeat():
{}
{
	< REPEAT > 
	(		< NUMERO >
| 		(			< ID >
			{
  				if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  					{
					  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
					  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
				  	}
			 }
		)
	)

	

	"["
		// TODO: Comandos/ Toca hacer una RP para que se incluyan los comandos separados por /n
		comandosMain()
	"]"
}


void ifCommand():
{}
{
	< IF >  < BLOCKEDP > 
	"["
		// TODO: Comandos/ Toca hacer una RP para que se incluyan los comandos separados por /n
		// TODO: Conectar con robot mate
		comandosMain() (comandosMain())*
	"]"
}


void define():
{
	String llave = "";
	int valor = 0;
}
{
	< DEFINE >  < ID >
	{
	  llave = token.image;
	}


	 < NUMERO >
	{
	  valor = Integer.parseInt(token.image);
	  varDefinidas.put(llave, valor);
	}
}


void to(): // TODO: Aceptar recursividad
{
	ArrayList<String > paramsArray = new ArrayList<String>();
}
{
	< TO >  < ID > (" :" < ID >)* // TODO: Revisar parámetros
	("\n")*< OUTPUT >
	(comandosMain())+
	("\n")* < END >
}


void comandosMain(): // Todos los comandos separados por nuevas líneas, como aparecería en la interfaz
{ }
{
 	("\n")*
	(
	 move()
| 	 right()
| 	 left()
| 	 rotate()
| 	 look()
| 	 drop()
| 	 free()
| 	 pick()
| 	 pop()
| 	 check()
| 	 < NOP >
| 	 block()
| 	 repeat()
| 	 ifCommand()
| 	 define()
| 	 to()
// FIN
	)
}



// Coso raro que es como el start symbol
boolean command(StringBuffer sistema) : //No sé para qué es ni cómo utilizarla.
{}
{
	(	 
	comandosMain() (comandosMain())*
	 
	  
	{return true;}
)| <EOF> {return false;}


}