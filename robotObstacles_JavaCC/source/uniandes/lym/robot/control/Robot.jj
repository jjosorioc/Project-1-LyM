/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
Eliminadas producciones para manejar globos
Agregado el esqueleto para la traduccion
Modificado por Silvia Takahashi 
Re: Agregar Reglas para el manejo de globos
Modificado por Saulo Daza y Sonia Vivas
Modificado por Silvia Takahashi
Eliminadas reglas de traducci�n DE  MARCROS
Cambio del lenguaje de comandos
Modificado por Silvia Takahashi: algunas Reglas para traduccion
Modificado por Silvia Takahashi: Cambio en el lenguaje
Abril: 2008 - Simplificado apra solo interpretaci�n
 **/

/*
Project 1
Juan José Osorio Cálad 202021720 j.osorio
Luis Alejandro Rubiano

*/

options 
{
	LOOKAHEAD=2;
	FORCE_LA_CHECK = true; // salen dos warnings de: Choice conflict involving two expansions at...
	IGNORE_CASE = false;
	STATIC = false;
	
}
   

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

@SuppressWarnings("serial")
public class Robot 
{
	// ArrayList<String > varDefinidas = new ArrayList(); // Variables definidas

	HashMap<String, Integer > varDefinidas = new HashMap<String, Integer >();

	HashMap<String, String > funcDefinidas = new HashMap<String, String >();

	private RobotWorldDec world;
	
	
	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}

	String salida=new String();
}
PARSER_END(Robot)

SKIP:
{
	" "
	| "    "
	|  "\r"
	|"\t"
//	|"\n" 
}

TOKEN: /* Nombres de Comandos */
{
	< MOVE: "MOVE" > //INT where n is a number or a previously defined variable
| 	< RIGHT: "RIGHT" > //INT where n is a number or a previously defined variable
|	< LEFT: "LEFT" > //INT where n is a number or a previously defined variable
|	< ROTATE: "ROTATE" > //INT where n is a number or a previously defined variable
|	< LOOK: "LOOK" > // STRING where O can be N, E, W, or S
|	< DROP: "DROP" > // INT where n is a number or a previously defined variable
|	< FREE: "FREE" > // INT where n is a number or a previously defined variable
|	< PICK: "PICK" > // INT where n is a number or a previously defined variable
|	< POP: "POP" > // INT where n is a number or a previously defined variable
|	< CHECK: "CHECK" > // where O is either C for chips, or B for balloons, and n is a previously defined variable or a number
|	< BLOCKEDP: "BLOCKEDP" > //Boolean
|	< NOP: "NOP" > // The Robot doesn't do anything
}



TOKEN: /* Nombres de Comandos Especiales*/
{
	< BLOCK: "BLOCK" > // (BLOCK commands) where commands is simply a sequence of one or more commands (separated by new lines)
|	< REPEAT: "REPEAT" > /*
REPEAT n [commands], where n is a variable or a number
describing the number of times the commands inside the [] will repeat, and
commands is a sequence of basic commands separated by new lines
*/
| 	< IF: "IF" > /*
IF expr [ commands ], where expr is a boolean ex-
pression, and commands is a sequence of basic commands separated by new
lines
*/
| 	< DEFINE: "DEFINE" > /*
DEFINE n val – defines a new variable n assigning it value val (an integer).
Note that variable names need to be lowercase
*/
| < TO: "TO" > /*
TO f :param OUTPUT expression END. Functions are defined between the TO
and END keywords, giving them a name f and a list of space separated parame-
ters each defined by the colons before its name (as in :param). The inner works
of a function are given as an expression or block of commands in its OUTPUT.
*/
| 	< OUTPUT: "OUTPUT" >
| 	< END: "END" >
}


TOKEN :
{
	<NUMERO: (<DIGIT>)+ >
	|  	<#DIGIT: ["0"-"9"] >
	// Identifier
	| < #LETRAS: ["a"-"z"] >
	| < #MAY: ["A"-"Z"] >
	| < ID: (< LETRAS >|< MAY >|< NUMERO >)+ >
	| < PARAM: (":" (< LETRAS >|< MAY >)+)>
		
}


// RP de movimientos
void move():
{}
{
  < MOVE >  (< NUMERO >
	{
		world.moveForward(Integer.parseInt(token.image));
	}

  
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  }else{
		world.moveForward(varDefinidas.get(token.image)); // Move the robot
		}
  
}
| < PARAM >)
)
}


void right():
{ }
{
	< RIGHT >  (< NUMERO >
	{
	  int valorNum = Integer.parseInt(token.image); // valor del token como int

	  if (valorNum < 0 || valorNum > 360) // if valorNum is not in the accepted range
	  {
		   throw new Error("Degrees should be in [0, 360]!");
	  }
	  else { 

		  if (0 < valorNum && valorNum <= 90) // Clockwise
		  {
		    world.turnRight();
		  }
		  else if (90 < valorNum && valorNum <= 180)
		  {
		    world.turnRight();
		    world.turnRight();
		  }
		  else if (180 < valorNum && valorNum <= 270)
		  {
		    world.turnRight();
		    world.turnRight();
		    world.turnRight();
		  }
		}
	}

  
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  }
  else{
	  int valorNum = varDefinidas.get(token.image); 

	  if (valorNum < 0 || valorNum > 360) // if valorNum is not in the accepted range
	  {
		   throw new Error("Degrees should be in [0, 360]!");
	  }
	  else { 

		  if (0 < valorNum && valorNum <= 90) // Clockwise
		  {
		    world.turnRight();
		  }
		  else if (90 < valorNum && valorNum <= 180)
		  {
		    world.turnRight();
		    world.turnRight();
		  }
		  else if (180 < valorNum && valorNum <= 270)
		  {
		    world.turnRight();
		    world.turnRight();
		    world.turnRight();
		  }
		}
	}
  
}
| < PARAM >))
}


void left():
{ }
{
	< LEFT >  (< NUMERO >
	{
	  int valorNum = Integer.parseInt(token.image); // valor del token como int

	  if (valorNum < 0 || valorNum > 360) // if valorNum is not in the accepted range
	  {
		   throw new Error("Degrees should be in [0, 360]!");
	  }
	  else { 

		  if (0 < valorNum && valorNum <= 90) // Clockwise
		  {
		    world.turnRight();
		    world.turnRight();
		    world.turnRight();
		  }
		  else if (90 < valorNum && valorNum <= 180)
		  {
		    world.turnRight();
		    world.turnRight();
		  }
		  else if (180 < valorNum && valorNum <= 270)
		  {
		    world.turnRight();
		  }
		}
	}

  
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  }else{
		world.moveForward(varDefinidas.get(token.image)); // Move the robot
		}
  
}
| < PARAM >))
}


void rotate()://TODO
{ }
{
	< ROTATE >  (< NUMERO > // Se asume que el # de grados está entre 0 <= # <= 360
	
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  {
  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}
 }
| < PARAM >))
}


void look():
{
	ArrayList<String> charValidos = new ArrayList<String>(Arrays.asList("N", "S", "E", "W"));
	HashMap<String, Integer > faceL = new HashMap<String, Integer >();
	faceL.put("N",0);
	faceL.put("S",1);
	faceL.put("E",2);
	faceL.put("W",3);
}
{
	< LOOK >  < ID >
	{

	if (!(charValidos.contains(token.image))) // Check if CHAR is in charValidos
	{
		throw new Error("\""+ token.image + "\"" + " should be either \"N\", \"S\", \"E\", \"W\"!");
	}
	else
	{
		boolean centinela = true;
		while (centinela)
		{
			if (world.getFacing() != faceL.get(token.image))
			{
				world.turnRight();	
			}
			else { centinela = false; }

		}

	 }

	}
}

void drop():
{ }
{
	< DROP>  (< NUMERO >
	{
		world.putChips(Integer.parseInt(token.image));
	}

	
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
    {
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}else
  	{
		world.putChips(varDefinidas.get(token.image));
  	}
 }
| < PARAM >))
}


void free():
{ }
{
	< FREE >  (< NUMERO >
	{
		world.putBalloons(Integer.parseInt(token.image));
	}	
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
    {
  	 	throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}else
  	{
		world.putBalloons(varDefinidas.get(token.image));
  	}
 }
| < PARAM >))
}


void pick():
{ }
{
	< PICK >  (< NUMERO >
	{
		world.pickChips(Integer.parseInt(token.image));
	}
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
    {
  	 	throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}else
  	{
		world.pickChips(varDefinidas.get(token.image));
  	}
 }
| < PARAM >))
}


void pop():
{ }
{
	< POP >  (< NUMERO >
	{
	 	world.popBalloons(Integer.parseInt(token.image));
	}
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
    {
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}else
  	{
		world.popBalloons(varDefinidas.get(token.image));
  	}
 }
| < PARAM >))
}


boolean check():// TODO: retorna un boolean?
{
	ArrayList<String> charValidos = new ArrayList<String>(Arrays.asList("C", "B"));
	String opcion = "";
}
{
	< CHECK >  < ID >
	{
		if(!(charValidos.contains(token.image)))
		{
			throw new Error("\""+ token.image + "\"" + " should be \"C\" or \"B\"!");
		}else // Guardar la opción entre C o B
		{
		  	opcion = token.image;
		 }
	}
	
	(< NUMERO >
	{
		if (opcion.equals("B")) // contar Balloons
		{
		  	return (Integer.parseInt(token.image) == world.countBalloons());
		 }else // contar chips
		 {
		   	return (Integer.parseInt(token.image) == world.chipsToPick());
		  }
	}
| 	(< ID >
{
  if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
    {
  	  
  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
  	}else
  	{
		if (opcion.equals("B")) // contar Balloons
		{
		  	return (varDefinidas.get(token.image) == world.countBalloons());
		 }else // contar chips
		 {
		   	return (varDefinidas.get(token.image) == world.chipsToPick());
		  }
  	 }
 }
| < PARAM >))
}


/**
*@returns boolean, true if Robot is blocked.
*/
boolean blockedp():
{ }
{
  	< BLOCKEDP >
	{
		int direccion = world.getFacing(); // direcció del Robot
		Point puntoR = world.getPosition(); // Punto en el que se encuentra el Robot

		// Según su dirección se calcula el punto "al frente"
		if (direccion == 0)
		{
		  System.out.println(world.isBlocked(new Point(puntoR.x, puntoR.y - 1)));
		  return (world.isBlocked(new Point(puntoR.x, puntoR.y - 1)));
		}
		else if (direccion == 1)
		{
		  System.out.println(world.isBlocked(new Point(puntoR.x, puntoR.y + 1)));
		  return (world.isBlocked(new Point(puntoR.x, puntoR.y + 1)));
		}
		else if (direccion == 2)
		{
		  System.out.println(world.isBlocked(new Point(puntoR.x + 1, puntoR.y)));
		  return (world.isBlocked(new Point(puntoR.x + 1, puntoR.y)));
		}
		else if (direccion == 3)
		{
		  System.out.println(world.isBlocked(new Point(puntoR.x - 1, puntoR.y)));
		  return (world.isBlocked(new Point(puntoR.x - 1, puntoR.y)));
		}
	}
}


// NOP


void block():
{}
{
	"(" < BLOCK > 

	
	 (comandosMain())+

	
	(")"|("\n")+ ")") // Final de paréntesis
}


void repeat():
{}
{
	< REPEAT > 
	(		< NUMERO >
| 		(			< ID >
			{
  				if(!(varDefinidas.containsKey(token.image)))// Check if token.image is in the Array
  					{
					  	  // System.out.println("\""+ token.image + "\"" + " is not defined!"); // Luego toca lanzar un error.
					  	  throw new Error("\""+ token.image + "\"" + " is not defined!");
				  	}
			 }
		| < PARAM >))
	

	

	"["
		
		(comandosMain())+
	"]"
}


void ifCommand():
{}
{
	< IF > ("!")? blockedp() ("\n")* // TODO: Aceptar !
	"["
		
		// TODO: Conectar con robot mate
		(comandosMain())+
	("\n")*
	"]"
}


void define():
{
	String llave = "";
	int valor = 0;
}
{
	< DEFINE >  < ID >
	{
	  llave = token.image;
	}


	 < NUMERO >
	{
	  valor = Integer.parseInt(token.image);
	  varDefinidas.put(llave, valor);
	}
}


void to(): // TODO: Aceptar recursividad
{
	ArrayList<String > paramsArray = new ArrayList<String>();
}
{
	< TO >  < ID >
	// Agregar el nombre de la función al hashMap
	{
		funcDefinidas.put(token.image, "Works");
		System.out.println(funcDefinidas.toString());
	}


	(< PARAM >)* // TODO: Revisar parámetros
	("\n")*< OUTPUT >
	
	(comandosMain() // TODO: Crear NT para guardar tokens.
	{
		paramsArray.add(token.image);
		System.out.println(paramsArray.toString());

	}

	)+
	("\n")* < END >
}


void comandosMain(): // Todos los comandos separados por nuevas líneas, como aparecería en la interfaz
{ }
{
 	("\n")*
	(
	 move()
| 	 right()
| 	 left()
| 	 rotate()
| 	 look()
| 	 drop()
| 	 free()
| 	 pick()
| 	 pop()
| 	 check()
| 	 < NOP >
| 	 block()
| 	 repeat()
| 	 ifCommand()
| 	 define()
| 	 to()
// FIN
	)
}



// Coso raro que es como el start symbol
boolean command(StringBuffer sistema) : //No sé para qué es ni cómo utilizarla.
{}
{
	(	 
	comandosMain() (comandosMain())*
	 
	  
	{return true;}
)| <EOF> {return false;}


}